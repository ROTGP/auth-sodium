
# AuthSodium

AuthSodium is a [Laravel](https://laravel.com/)
package for authenticating API requests with LibSodium's
[public-key (ED25519)
signatures](https://libsodium.gitbook.io/doc/public-key_cryptography/public-key_signatures).
Sodium is available natively in PHP since version 7.2
without an extension. Some objectives of the package:
  * use modern security standards
  * provide stateless RESTful API asymmetric authentication
  * remove complexity of clients having to request/renew tokens
  * remove the need of sending sensitive credentials (such as
    passwords) to the server
  * offload memory/cpu intensive work (such as [slow
    password hashing](https://en.wikipedia.org/wiki/Key_derivation_function#Password_hashing)) from the server to the client
  * manage
    [nonces](https://en.wikipedia.org/wiki/Cryptographic_nonce)
    transparently
  * throttle and block malicious users
  * highly customizable
  * non-invasive
  * no dependencies (other than Laravel itself)
  * thoroughly tested
  * fast and lightweight
  * support Laravel 7+


## What is a stateless API? 

Put simply, each request must contain all of the information necessary to be understood by the server, rather than be dependent on the server remembering prior requests.


## How LibSodium works

The package works by verifying the signature sent with
each authenticated request. Your user model should
contain a public key for each user.


### User registration

How you choose to manage the user's public and private
keys is up to you, however, the following is potential
workflow for user registration:

 - choose appropriate LibSodium
   [bindings](https://libsodium.gitbook.io/doc/bindings_for_other_languages)
   for your client
 - user provides email and chooses a password
 - input password into a
   [PBKDF](https://en.wikipedia.org/wiki/PBKDF2)
   (several options are provided by
   [LibSodium](https://libsodium.gitbook.io/doc/password_hashing))
   to produce cryptographically secure pseudo-random
   bytes
 - input bytes into LibSodium's
   [crypto_sign_seed_keypair](https://libsodium.gitbook.io/doc/public-key_cryptography/public-key_signatures#key-pair-generation)
   function to deterministically produce the user's
   public and private keys
 - send the user's email address and public key to the
   server to be registered, being sure to sign the
   request with the user's private key, to ensure that
   the public key is valid

The request must contain headers
with the following metadata: 
 - a unique identifier for the
user to be authenticated (like an email address)
 - a
   [nonce](https://en.wikipedia.org/wiki/Cryptographic_nonce)
 - a timestamp
 - a signature


The signature, which is generated by the client, is calculated by signing data
related to each request. This data is comprised of:
 - the HTTP **request method** (`get`, `put`, `post`, or `delete`)
 - the fully qualified **URL** of the request (with the
   `http://` or `https://www`), but without any query
   strings
 - **query data** (sorted alphabetically and
   json-encoded), or an empty string in the absense of
   query data
 - **post data** (json-encoded), or an empty string in
   the absense of post data
 - **user identifier** (such as the user's email address)
 - **timestamp** (in milliseconds, unless using a 32-bit
   version of PHP, in which case it should be in
   seconds) since midnight January 1st 1970 (UTC)
 - **nonce** (a number or string which should not be repeated)

This data is then concatenated to make a single string,
which is then signed with the user's private key. The
signature is then sent as a header.

On the server side, this string is reconstructed. Once
the auth user has been retrieved, their public key is
used to verify the signature. If the signature fails
then the appropriate error response is returned,
otherwise, the request continues as per normal.

## Installation

1) Require this package with composer.

```shell
composer require rotgp/auth-sodium
```

2) Publish the AuthSodium config file to your project with
   the following command:

```shell
php artisan vendor:publish --provider="ROTGP\AuthSodium\AuthSodiumServiceProvider" --tag="config"
```

3) Configure your [user model](#user-model)

4) Review the [database schema options](#database-schema)

5) Run `php artisan migrate`

<br />

# Configuration

Assuming you've performed the above installation, the
config file can then be found at
`config/authsodium.php`. 

## User Model
The only thing you're required to tell AuthSodium
about is the class of your user model. This must extend
`Illuminate\Database\Eloquent\Model`, and implement
`Illuminate\Contracts\Auth\Authenticatable`. For
convenience, the model may simply extend
`ROTGP\AuthSodium\Models\AuthSodiumUser` which already
meets these requirements.

```config
'user.model' => App\Models\User::class
```

AuthSodium needs to know how to uniquely identify your
auth user. By default, this will be with the user's
`'email'` attribute, but you may choose anything, such
as username or even an id (assuming the user knows
their own id). 

```config
'user.unique_identifier' => 'username'
```

You should also note that AuthSodium will look for the
user's public key using the `'public_key'` attribute of
the user model. If you wish to call it something else,
then you may do so as follows:

```config
'user.public_key_identifier' => 'pub_key'
```

<br />
<br />


## Specify a delegate
Customizing the package's config values should be enough
for most use-cases, but if you require more fine-grained
control of the AuthSodium's logic, you may specify a
custom delegate. By default the delegate points to
[`ROTGP\AuthSodium\AuthSodiumDelegate`](https://github.com/ROTGP/auth-sodium/blob/master/src/AuthSodiumDelegate.php),
but you can extend this class and override any
functionality you like. Simply update the config value
to point to your custom class as follows:

```config
'delegate' => 'My\Custom\AuthDelegate::class'
```
<br />
<br />

## Database schema

Before running AuthSodium's migration, you should
consider the following options.

### Nonce length

The length of the database column for nonce. By default
it's 44, which is 32 base64-encoded bytes. For hex
encoded nonces, the length should be 64. Note that this
is just a plain string (or integer as a string). It is
convenient to generate random bytes with a CSPRNG and
encode them as hex or base64, but in the end it's just a
string.

```config
'schema.nonce.length' => 44
```

### Nonce uniqueness

Whether or not the nonce should be unique per
user/timestamp.

If true, then a unique constraint for
user/nonce/timestamp will be created at database level,
meaning that a nonce can be reused if it has a different
timestamp. A request with a repeating
user/nonce/timestamp will still be rejected if the
timestamp does not fall within `leeway` of the system
time. This allows for more margin or error (random
nonces being repeated), as the nonces must only be
unique within `leeway` of the system time.

If false (the default), then the unique constraint will
be for the user/nonce, regardless of the timestamp. So,
if user/nonce is repeated (even if days apart), an
exception will occur. This means that in order to avoid
conflicts, nonces should be cleared regularly (the
default).

In either case, using 256-bit nonces generated by a
CSPRNG should be more than sufficient to ensure no
accidental collisions occur.  More discussion here:
[here](https://crypto.stackexchange.com/a/41173/4557).

```config
'schema.nonce.unique_per_timestamp' => false
```

<br />
<br />



## Protecting routes with middleware

### Named Middleware

By default, AuthSodium provides middleware called
`'authsodium'`. To protect a route, simply add the
middleware in the same way you'd normally add middleware
`Route::resource('foos',
FooController::class)->middleware('authsodium');` The
name of the middleware can be customized as follows:

```config
'middleware.name' => 'custom_middleware_name'
```
<br />

### Global Middleware
If you want to protect all incoming requests
automatically, then set `'middleware.global'` to true:

```config
'middleware.global' => true
```
<br />

### Middleware groups
If you want to add AuthSodium to a particular middleware
group (such as 'web', or 'api'), then you may do so as follows:

```config
'middleware.group' => 'api'
```
<br />

### Aborting requests

By default, AuthSodium will abort requests with invalid
signatures automatically, with the appropriate status
and error codes (which are customizable). There may
however be situations where you wish to proceed with the
request, without establishing an authenticated user. To
achieve this - adjust the following value:

```json
'middleware.abort_on_invalid_signature' => false
```
<br />
<br />



## Leeway

By default, AuthSodium provides middleware called
`'authsodium'`. To protect a route, simply add the
middleware in the same way you'd normally add middleware
`Route::resource('foos',
FooController::class)->middleware('authsodium');` The
name of the middleware can be customized as follows:

```config
'middleware.name' => 'custom_middleware_name'
```
<br />
<br />


## Nonce pruning

For security reasons, AuthSodium must keep a record (in
the database) of all the nonces used for a particular user
(and possibly also timestamp, according to
`authsodium.schema.nonce.unique_per_timestamp`), where
the nonce is not older than the value of
`authsodium.leeway`. Nonces that are older than this
value can be safely (and automatically)
deleted on a periodic basis.



#### After each request

Bar

```config
'foo' => 'bar'
```
<br />
<br />



<br /><br /><br /><br /><br />

# License

AuthSodium is provided under the [MIT License](https://github.com/vhesener/Closures/blob/master/LICENSE).
