<?php

return [

    /**
     * The class containing core the logic. Must point
     * directly to either the delegate, or if custom
     * functionality is desired, a class which extends
     * ROTGP\AuthSodium\AuthSodiumDelegate.
     */
    'delegate' => ROTGP\AuthSodium\AuthSodiumDelegate::class,
    
    'schema' => [

        'nonce' => [

            /**
             * The length of the nonce for the database
             * column. By default it's 44, which is 32
             * base64 encoded bytes.
             */
            'length' => 44,
        ],

        /**
         * https://stackoverflow.com/a/6876907/1985175
         * https://crypto.stackexchange.com/a/41173/4557
         *
         * If true, then a unique constraint for
         * user/nonce/timestamp will be created at the
         * database level, meaning that a nonce can be
         * reused if it has a different timestamp. A
         * request with a repeating user/nonce/timestamp
         * will still be rejected if the timestamp does
         * not fall within `timestamp.leeway` seconds of
         * the system time. This allows for more margin
         * or error (random nonces being repeated), as
         * the nonces must only be unique within
         * `timestamp.leeway` seconds of the system
         * time.
         *
         * If false, then the unique constraint will be
         * for the user/nonce, regardless of the
         * timestamp. So, if user/nonce is repeated
         * (even if days apart), an exception will
         * occur. This means that in order to avoid
         * conflicts, nonces should be cleared regularly
         * (the default).
         *
         * In either case, using base-64 encoded 256-bit
         * nonces generated by a CSPRNG should be more
         * than sufficient to ensure no accidental
         * collisions occur.
         */
        'nonce_unique_per_timestamp' => false
    ],
    

    'user' => [
        /**
         * The model class to be used for all auth
         * operations. The only requirements are that the
         * model should extend
         * Illuminate\Database\Eloquent\Model, and should
         * implement
         * Illuminate\Contracts\Auth\Authenticatable. For
         * convenience's sake, the model may extend
         * ROTGP\AuthSodium\Models\AuthSodiumUser.
         */
        'model' => null,

        /**
         * The name of the model field/column used to
         * uniquely identify the user.
         */
        'unique_identifier' => 'email',

        /**
         * The name of the model field/column used for
         * storing the public key
         */
        'public_key_identifier' => 'public_key',
    ],

    /**
     * Return a string to 'glue' together the pieces of
     * the signature array together.
     */
    'glue' => '',
    
    'header_keys' => [
        'nonce' => 'Auth-Nonce',
        'timestamp' => 'Auth-Timestamp',
        'user_identifier' => 'Auth-User',
        'signature' => 'Auth-Signature'
    ],

    'guard' => [

        /**
         * Return a string to identify the guard name,
         * which is essentially an alias. If this is
         * specified, then the Auth facade itself will
         * be remain untouched, and instead you can use
         * Auth::guard('name'). For example, given the
         * name: 'authsodium', instead of using
         * Auth::user(), you would use
         * `Auth::guard('authsodium')->user()`. See more
         * examples as follows:
         *
         * - Auth::guard('authsodium')->check() // bool
         *
         * - Auth::guard('authsodium')->user() //
         *   object|null
         *
         * - Auth::guard('authsodium')->id() //
         *   int|string|null
         *
         * - Auth::guard('authsodium')->guest() // bool
         *
         * - Auth::guard('authsodium')->authenticateSignature()
         *   // bool
         *
         * - Auth::guard('authsodium')->invalidate()
         *   // bool
         *
         */
        'name' => null
    ],

    'middleware' => [

        /**
         * Return a string to add AuthSodium middleware
         * to a middleware group. For example, 'web' or
         * 'api'.
         */
        'group' => null,

        /**
         * Return a string to identify the AuthSodium
         * middleware. Return null if you don't wish to
         * define a dedicated middleware (ie, if using
         * guards, or appending the middleware to
         * another group).
         *
         * Assuming we return a string, (such as
         * 'authsodium'), then we can apply the
         * middleware in several different ways.
         *
         * Per route:
         *
         *  Route::resource('foos',
         *  FooController::class);
         *  //->middleware('authsodium');
         *
         * Per controller (in the contoller's
         * constructor):
         *
         *  public function __construct()
         *  {
         *     $this->middleware('authsodium');
         *     // $this->middleware('authsodium')->only('index');
         *     // $this->middleware('authsodium')->except('index');
         * }
         *
         * See more here:
         * https://laravel.com/docs/8.x/middleware
         */
        'name' => 'authsodium',

        /**
         * Return true to run AuthSodium middleware
         * implicitly on all requests. False by default
         * as it's not very flexible.
         */
        'use_global' => false,

        /**
         * If true, requests will be aborted when the
         * middleware is run and the request is lacking
         * the appropriate auth signature (or associated
         * headers).
         *
         * If false, then requests lacking a signature
         * will proceed, but Auth::user() will be null.
         */
        'abort_on_invalid_signature' => true
    ],

    /**
    * This should be considered an extra precaution as
    * the login status should disappear when the app
    * terminates, however, it may prove to be useful in
    * the future (long-running processes, octane, swoole
    * etc).
    *
    * https://laravel.com/docs/8.x/middleware#terminable-middleware
    *
    * If true, and your server supports terminating
    * middleware, then Auth::invalidate will
    * be called explicitly after the response has been
    * sent to the browser. An attempt will also be made
    * via the `$this->app->terminating` method, however,
    * for long-running processes this is less useful.
    */
    'log_out_after_request' => true,


    /**
     * Check that the nonce table exists before pruning.
     * It may not exist in some cases (such as on
     * terminating the application and before migrations
     * have been performed). If you're sure the nonces
     * tables exists, then set to false for a slight
     * performance optimization.
     */
    'check_nonces_table_before_pruning' => true,

    /**
     * Prune nonces on terminating a request (via
     * middleware). As per log_out_after_request, this
     * will only apply if using middleware, and the
     * server supports it.
     */
    'prune_nonces_after_request' => true,

    /**
     * Prune nonces when the application terminates.
     * This also includes when run via the cli.
     */
    'prune_nonces_on_terminate' => false,

    'encoding' => 'base64', // or 'hex'

    
    'http_status_codes' => [

        /**
         * When all the associated metadata has been
         * provided and validated, but the signature is
         * invalid.
         */
        'unauthorized' => 401,

        /**
         * User has been blocked because they have
         * exceeded the allowable amount of failed
         * authentication requests, as defined in
         * `throttle.decay`, or because their account is
         * not currently enabled (as defined by calling
         * the 'enabled' method on the model, and
         * receiving a false result).
         */
        'forbidden' => 403,

        /**
         * The user and IP address have attempted too
         * many failed authenticated requests, and a
         * period of time must be observed before
         * attempting again.
         */
        'too_many_requests' => 429,

        /**
         * Some metadata related to the authentication
         * was incorrect, invalid, or missing. Examples:
         * - nonce_not_found
         * - nonce_exceeds_max_length
         * - timestamp_not_found
         * - nonce_already_exists
         * - signature_not_found
         * - signature_invalid_length
         * - invalid_timestamp_format
         * - onValidationError
         * - user_identifier_not_found
         * - user_public_key_identifier_not_found
         * - user_public_key_not_found
         * - onValidationError
         * - unable_to_build_signature_string
         */
        'validation_error' => 422 // some people prefer 400
    ],

    'timestamp' => [
        
        /**
         * Whether to use milliseconds (true) or seconds
         * (false) when dealing with timestamps. The
         * dicates what the end-user should send, and
         * also what to expect interally when validating
         * timestamps, and deleting them.
         */
        'milliseconds' => true,

        /**
         * The leeway (in seconds, or milliseconds,
         * depending on the value of
         * `use_milliseconds`), on either side of the
         * timestamp, in which to allow valid
         * timestamps. A leeway of 300000 milliseconds
         * (the default) equates to a request timestamp
         * within 5 minutes (before or after) the
         * current system timestamp being accepted. The
         * larger the value, the more forgiving the
         * service, but this will also result in more
         * nonces being stored at any given time. This,
         * however, should not be a concern, as nonce
         * deletion is managed automatically.
         * 
         * 300000 milliseconds = 300 seconds = 5 minutes
         */ 
        'leeway' => 300000
    ],

    /**
     * Configure how failed authentication attempts are
     * managed.
     */
    'throttle' => [

        /**
         * Whether or not throttling is currently
         * enabled.
         */
        'enabled' => true,

        /**
         * The invervals (in seconds) after which a new
         * authentication attempt can be made, after
         * having made an initial failed one. Zero
         * indicates that an attempt can be made
         * immediately. Intervals are relative to the
         * preceding one, so the default would allow
         * three consecutive immediate attempts, then an
         * attempt in 1 second, then 3 seconds following
         * that, etc. After the last attempt (the 8th,
         * by default) fails, the user is considered to
         * be blocked.
         */
        'decay' => [0, 0, 0, 1, 3], // [0, 0, 0, 1, 3, 10, 60, 300],

        /**
         * Throttling will not be applied at all for
         * these environments.
         */
        'exclude_environments' => ['local'],

        /**
         * If true (the default), will only throttle
         * automated middleware authentications, not
         * explicit calls such as
         * `Auth::authenticateSignature()` or
         * `Auth::guard('authsodium')->authenticateSignature()`
         */
        'middleware_only' => true
    ],

    'error_codes' => [
        'user_not_found' => 0,
        'user_not_enabled' => 0,
        'user_identifier_not_found' => 0,
        'user_public_key_identifier_not_found' => 0,
        'user_public_key_not_found' => 0,
        'invalid_signature' => 0,
        'signature_not_found' => 0,
        'timestamp_not_found' => 0,
        'invalid_timestamp_format' => 0,
        'invalid_timestamp_range' => 0,
        'unable_to_build_signature_string' => 0,
        'nonce_not_found' => 0,
        'nonce_exceeds_max_length' => 0,
        'nonce_already_exists' => 0,
        'too_many_requests_please_wait' => 0,
        'too_many_requests_forbidden' => 0
    ],
];
